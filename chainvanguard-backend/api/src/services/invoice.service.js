import easyinvoice from "easyinvoice";
import Invoice from "../models/Invoice.js";
import VendorRequest from "../models/VendorRequest.js";
import VendorInventory from "../models/VendorInventory.js";
import Order from "../models/Order.js";
import ipfsService from "./ipfs.service.js";
import fabricService from "./fabric.service.js";
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class InvoiceService {
  /**
   * AUTO-GENERATE INVOICE FOR CUSTOMER ORDER
   * Called automatically when order is paid/delivered
   */
  async generateOrderInvoice(order, customer, seller) {
    try {
      console.log(`üìÑ Auto-generating invoice for order: ${order.orderNumber}`);

      // Determine payment status and notes based on order status
      let paymentStatus = order.paymentStatus || "paid";
      let notes = `Invoice for order #${order.orderNumber}`;
      let terms = "Payment has been received. Thank you for your business!";

      // Handle cancelled/refunded orders
      if (order.status === "cancelled" && order.paymentStatus === "refunded") {
        paymentStatus = "refunded";
        notes = `CANCELLED - Order #${order.orderNumber} - Refunded on ${new Date(order.refundedAt || new Date()).toLocaleDateString()}`;
        terms = `This order has been cancelled. CVT ${order.total.toFixed(2)} has been refunded to customer wallet. Reason: ${order.cancellationReason || "Customer request"}`;
      } else if (order.status === "delivered") {
        notes = `Invoice for delivered order #${order.orderNumber}`;
        terms = "Order delivered successfully. Payment received. Thank you for your business!";
      }

      // Prepare invoice data
      const invoiceData = {
        type: "customer_order",
        relatedEntity: {
          entityType: "order",
          entityId: order._id,
        },
        from: {
          userId: seller._id,
          name: seller.name || seller.companyName,
          companyName: seller.companyName,
          email: seller.email,
          phone: seller.phone,
          address: {
            street: seller.businessAddress || seller.address,
            city: seller.city,
            state: seller.state,
            country: seller.country,
            postalCode: seller.postalCode,
          },
          walletAddress: seller.walletAddress,
        },
        to: {
          userId: customer._id,
          name: customer.name,
          email: customer.email,
          phone: customer.phone,
          address: order.shippingAddress || {
            street: customer.address,
            city: customer.city,
            state: customer.state,
            country: customer.country,
            postalCode: customer.postalCode,
          },
          walletAddress: customer.walletAddress,
        },
        items: order.items.map((item) => ({
          description: `${item.productName || item.name}`,
          quantity: item.quantity,
          unit: item.unit || "pcs",
          pricePerUnit: item.price,
          subtotal: item.subtotal || item.price * item.quantity,
        })),
        subtotal: order.subtotal,
        tax: order.tax || 0,
        shipping: order.shippingCost || 0,
        discount: order.discount || 0,
        total: order.total,
        currency: "CVT",
        paymentStatus: paymentStatus,
        paymentMethod: order.paymentMethod || "wallet",
        paymentDate: order.paidAt || new Date(),
        transactionHash: order.transactionHash,
        issueDate: new Date(),
        notes: notes,
        terms: terms,
        autoGenerated: true,
      };

      // Generate and upload invoice
      const invoice = await this._createAndUploadInvoice(invoiceData);

      console.log(`‚úÖ Invoice generated: ${invoice.invoiceNumber} (IPFS: ${invoice.ipfsHash})`);
      return invoice;
    } catch (error) {
      console.error("‚ùå Failed to generate order invoice:", error);
      throw error;
    }
  }

  /**
   * AUTO-GENERATE INVOICE FOR VENDOR REQUEST (Purchase Order)
   * Called automatically when vendor pays supplier
   */
  async generateVendorRequestInvoice(vendorRequest, vendor, supplier) {
    try {
      console.log(`üìÑ Auto-generating purchase invoice for request: ${vendorRequest.requestNumber}`);
      console.log(`üìã Vendor Request Details:`, {
        requestNumber: vendorRequest.requestNumber,
        total: vendorRequest.total,
        itemsCount: vendorRequest.items?.length || 0,
        vendorId: vendor?._id,
        supplierId: supplier?._id
      });

      const invoiceData = {
        type: "vendor_request",
        relatedEntity: {
          entityType: "vendor_request",
          entityId: vendorRequest._id,
        },
        from: {
          userId: supplier._id,
          name: supplier.name || supplier.companyName,
          companyName: supplier.companyName,
          email: supplier.email,
          phone: supplier.phone,
          address: {
            street: supplier.businessAddress || supplier.address,
            city: supplier.city,
            state: supplier.state,
            country: supplier.country,
            postalCode: supplier.postalCode,
          },
          walletAddress: supplier.walletAddress,
        },
        to: {
          userId: vendor._id,
          name: vendor.name || vendor.companyName,
          companyName: vendor.companyName,
          email: vendor.email,
          phone: vendor.phone,
          address: {
            street: vendor.businessAddress || vendor.address,
            city: vendor.city,
            state: vendor.state,
            country: vendor.country,
            postalCode: vendor.postalCode,
          },
          walletAddress: vendor.walletAddress,
        },
        items: vendorRequest.items.map((item) => ({
          description: item.inventoryName || item.name || `Inventory Item`,
          quantity: item.quantity,
          unit: item.unit || "units",
          pricePerUnit: item.pricePerUnit,
          subtotal: item.subtotal,
        })),
        subtotal: vendorRequest.subtotal,
        tax: vendorRequest.tax || 0,
        shipping: 0,
        discount: 0,
        total: vendorRequest.total,
        currency: "CVT",
        paymentStatus: "paid",
        paymentMethod: "wallet",
        paymentDate: vendorRequest.paidAt || new Date(),
        transactionHash: vendorRequest.paymentTxHash,
        issueDate: new Date(),
        notes: `Purchase order #${vendorRequest.requestNumber}`,
        terms: "Payment received. Inventory will be delivered as per agreement.",
        autoGenerated: true,
      };

      const invoice = await this._createAndUploadInvoice(invoiceData);

      console.log(`‚úÖ Purchase invoice generated: ${invoice.invoiceNumber}`);
      return invoice;
    } catch (error) {
      console.error("‚ùå Failed to generate vendor request invoice:", error);
      throw error;
    }
  }

  /**
   * AUTO-GENERATE RECEIPT FOR INVENTORY DELIVERY
   * Called automatically when vendor receives inventory
   */
  async generateInventoryReceipt(vendorInventory, vendor, supplier) {
    try {
      console.log(`üìÑ Auto-generating receipt for inventory delivery`);

      const invoiceData = {
        type: "inventory_receipt",
        relatedEntity: {
          entityType: "vendor_inventory",
          entityId: vendorInventory._id,
        },
        from: {
          userId: supplier._id,
          name: supplier.name || supplier.companyName,
          companyName: supplier.companyName,
          email: supplier.email,
          walletAddress: supplier.walletAddress,
        },
        to: {
          userId: vendor._id,
          name: vendor.name || vendor.companyName,
          companyName: vendor.companyName,
          email: vendor.email,
          walletAddress: vendor.walletAddress,
        },
        items: [
          {
            description: vendorInventory.inventoryItem?.name || "Inventory Material",
            quantity: vendorInventory.quantity.received,
            unit: vendorInventory.quantity.unit || "units",
            pricePerUnit: vendorInventory.cost.perUnit,
            subtotal: vendorInventory.cost.totalCost,
          },
        ],
        subtotal: vendorInventory.cost.totalCost,
        tax: 0,
        shipping: 0,
        discount: 0,
        total: vendorInventory.cost.totalCost,
        currency: vendorInventory.cost.currency || "CVT",
        paymentStatus: "paid",
        paymentDate: vendorInventory.dates.received,
        issueDate: new Date(),
        notes: `Inventory delivery receipt - ${vendorInventory.quantity.received} ${vendorInventory.quantity.unit} received`,
        terms: "Received in good condition.",
        autoGenerated: true,
      };

      const invoice = await this._createAndUploadInvoice(invoiceData);

      console.log(`‚úÖ Receipt generated: ${invoice.invoiceNumber}`);
      return invoice;
    } catch (error) {
      console.error("‚ùå Failed to generate inventory receipt:", error);
      throw error;
    }
  }

  /**
   * CORE: Create Invoice, Generate PDF, Upload to IPFS, Record on Blockchain
   */
  async _createAndUploadInvoice(invoiceData) {
    // 1. Create invoice in MongoDB
    const invoice = new Invoice(invoiceData);
    await invoice.save();

    console.log(`üìù Invoice created in MongoDB: ${invoice.invoiceNumber}`);

    try {
      // 2. Generate PDF using easyinvoice
      console.log(`üîÑ Generating PDF for invoice: ${invoice.invoiceNumber}`);
      const pdfBuffer = await this._generatePDF(invoice);
      console.log(`‚úÖ PDF generated successfully, size: ${pdfBuffer.length} bytes`);

      // 3. Upload PDF to IPFS using uploadBuffer (since we have a buffer, not a file path)
      console.log(`üîÑ Uploading PDF to IPFS: ${invoice.invoiceNumber}.pdf`);
      const ipfsResult = await ipfsService.uploadBuffer(
        pdfBuffer,
        `${invoice.invoiceNumber}.pdf`,
        {
          type: "invoice",
          invoiceNumber: invoice.invoiceNumber,
          invoiceType: invoice.type,
        }
      );

      console.log(`üì§ IPFS upload result:`, {
        success: ipfsResult.success,
        ipfsHash: ipfsResult.ipfsHash,
        error: ipfsResult.error
      });

      if (ipfsResult.success) {
        invoice.ipfsHash = ipfsResult.ipfsHash;
        invoice.ipfsUrl = ipfsResult.ipfsUrl;
        console.log(`‚úÖ Invoice uploaded to IPFS: ${ipfsResult.ipfsHash}`);

        // 4. Record on blockchain
        try {
          await fabricService.connect();
          const blockchainResult = await fabricService.recordInvoiceIssued({
            invoiceId: invoice._id.toString(),
            invoiceNumber: invoice.invoiceNumber,
            type: invoice.type,
            fromUserId: invoice.from.userId.toString(),
            toUserId: invoice.to.userId.toString(),
            total: invoice.total,
            currency: invoice.currency,
            ipfsHash: invoice.ipfsHash,
            issueDate: invoice.issueDate.toISOString(),
          });

          invoice.blockchain.verified = true;
          invoice.blockchain.txId = blockchainResult.txId;
          invoice.blockchain.recordedAt = new Date();
          console.log(`‚úÖ Invoice recorded on blockchain: ${blockchainResult.txId}`);
        } catch (blockchainError) {
          console.error("‚ö†Ô∏è Blockchain recording failed (non-critical):", blockchainError.message);
        } finally {
          await fabricService.disconnect();
        }
      } else {
        console.warn("‚ö†Ô∏è IPFS upload failed (non-critical)");
      }

      await invoice.save();
      return invoice;
    } catch (error) {
      console.error("‚ùå Invoice processing error:", error);
      // Still return invoice even if IPFS/blockchain fails
      return invoice;
    }
  }

  /**
   * Generate PDF using easyinvoice
   */
  async _generatePDF(invoice) {
    const data = {
      // Customize enables you to provide your own templates
      customize: {
        // "template": fs.readFileSync('template.html', 'base64') // Must be base64 encoded html
      },
      images: {
        // Logo can be added here if needed
        // logo: "base64_image_string"
      },
      sender: {
        company: invoice.from.companyName || invoice.from.name,
        address: invoice.from.address?.street || "",
        zip: invoice.from.address?.postalCode || "",
        city: invoice.from.address?.city || "",
        country: invoice.from.address?.country || "",
        custom1: `Email: ${invoice.from.email}`,
        custom2: `Wallet: ${invoice.from.walletAddress?.substring(0, 10)}...`,
      },
      client: {
        company: invoice.to.companyName || invoice.to.name,
        address: invoice.to.address?.street || "",
        zip: invoice.to.address?.postalCode || "",
        city: invoice.to.address?.city || "",
        country: invoice.to.address?.country || "",
        custom1: `Email: ${invoice.to.email}`,
        custom2: `Wallet: ${invoice.to.walletAddress?.substring(0, 10)}...`,
      },
      information: {
        number: invoice.invoiceNumber,
        date: invoice.issueDate.toLocaleDateString(),
        "due-date": invoice.dueDate ? invoice.dueDate.toLocaleDateString() : "Paid",
      },
      products: invoice.items.map((item) => ({
        quantity: item.quantity,
        description: item.description,
        "tax-rate": 0,
        price: item.pricePerUnit,
      })),
      "bottom-notice": invoice.terms || "Thank you for your business!",
      settings: {
        currency: invoice.currency,
        "tax-notation": "tax",
        "margin-top": 25,
        "margin-right": 25,
        "margin-left": 25,
        "margin-bottom": 25,
      },
      translate: {
        invoice: this._getInvoiceTitle(invoice.type),
        number: "Invoice Number",
        date: "Issue Date",
        "due-date": "Payment Status",
        subtotal: "Subtotal",
        products: "Items",
        quantity: "Qty",
        price: "Price",
        "product-total": "Total",
        total: "Total Amount",
      },
    };

    const result = await easyinvoice.createInvoice(data);
    return Buffer.from(result.pdf, "base64");
  }

  /**
   * Get invoice title based on type
   */
  _getInvoiceTitle(type) {
    const titles = {
      customer_order: "INVOICE",
      vendor_request: "PURCHASE ORDER",
      inventory_receipt: "DELIVERY RECEIPT",
      supplier_sale: "SALES INVOICE",
    };
    return titles[type] || "INVOICE";
  }

  /**
   * Get invoice by ID
   */
  async getInvoiceById(invoiceId) {
    return await Invoice.findById(invoiceId)
      .populate("from.userId", "name email companyName")
      .populate("to.userId", "name email companyName");
  }

  /**
   * Get invoices for a user (all invoices where user is sender or recipient)
   */
  async getUserInvoices(userId) {
    return await Invoice.find({
      $or: [{ "from.userId": userId }, { "to.userId": userId }],
    })
      .sort({ issueDate: -1 })
      .populate("from.userId", "name email companyName")
      .populate("to.userId", "name email companyName");
  }

  /**
   * Get invoices by related entity (e.g., all invoices for an order)
   */
  async getInvoicesByEntity(entityType, entityId) {
    return await Invoice.find({
      "relatedEntity.entityType": entityType,
      "relatedEntity.entityId": entityId,
    });
  }

  /**
   * Get invoice by IPFS hash
   * Useful for retrieving invoice when you only have the IPFS hash
   */
  async getInvoiceByIpfsHash(ipfsHash) {
    const invoice = await Invoice.findOne({ ipfsHash })
      .populate("from.userId", "name email companyName")
      .populate("to.userId", "name email companyName");

    if (!invoice) {
      throw new Error("Invoice not found for this IPFS hash");
    }

    return invoice;
  }

  /**
   * Search invoices by multiple criteria
   */
  async searchInvoices(userId, searchCriteria = {}) {
    const {
      invoiceNumber,
      type,
      status,
      paymentStatus,
      fromDate,
      toDate,
      minAmount,
      maxAmount,
    } = searchCriteria;

    const query = {
      $or: [{ "from.userId": userId }, { "to.userId": userId }],
    };

    if (invoiceNumber) {
      query.invoiceNumber = { $regex: invoiceNumber, $options: "i" };
    }

    if (type) {
      query.type = type;
    }

    if (status) {
      query.status = status;
    }

    if (paymentStatus) {
      query.paymentStatus = paymentStatus;
    }

    if (fromDate || toDate) {
      query.issueDate = {};
      if (fromDate) query.issueDate.$gte = new Date(fromDate);
      if (toDate) query.issueDate.$lte = new Date(toDate);
    }

    if (minAmount !== undefined || maxAmount !== undefined) {
      query.total = {};
      if (minAmount !== undefined) query.total.$gte = minAmount;
      if (maxAmount !== undefined) query.total.$lte = maxAmount;
    }

    return await Invoice.find(query)
      .sort({ issueDate: -1 })
      .populate("from.userId", "name email companyName")
      .populate("to.userId", "name email companyName");
  }

  /**
   * Download invoice PDF (returns buffer)
   * First tries to retrieve from IPFS, falls back to regenerating PDF
   */
  async downloadInvoice(invoiceId) {
    const invoice = await this.getInvoiceById(invoiceId);
    if (!invoice) {
      throw new Error("Invoice not found");
    }

    // If IPFS hash exists, try to fetch from IPFS
    if (invoice.ipfsHash) {
      try {
        console.log(`üì• Retrieving invoice from IPFS: ${invoice.ipfsHash}`);
        const ipfsResult = await ipfsService.getFile(invoice.ipfsHash);

        if (ipfsResult.success && ipfsResult.data) {
          console.log(`‚úÖ Invoice retrieved from IPFS: ${invoice.invoiceNumber}`);
          // IPFS returns the data as a buffer or string
          return Buffer.isBuffer(ipfsResult.data)
            ? ipfsResult.data
            : Buffer.from(ipfsResult.data);
        } else {
          console.warn(`‚ö†Ô∏è IPFS retrieval failed, regenerating PDF: ${ipfsResult.error}`);
        }
      } catch (ipfsError) {
        console.warn(`‚ö†Ô∏è IPFS retrieval error, regenerating PDF:`, ipfsError.message);
      }
    }

    // Fallback: Regenerate PDF if IPFS retrieval failed or no hash exists
    console.log(`üîÑ Regenerating invoice PDF: ${invoice.invoiceNumber}`);
    return await this._generatePDF(invoice);
  }
}

export default new InvoiceService();
